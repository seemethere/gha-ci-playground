name: comments_bot

concurrency:
  group: ${{ github.workflow }}-${{ github.event.pull_request.number || github.sha }}
  cancel-in-progress: true

on:
  issue_comment:
  pull_request:

jobs:
  dispatch_labels:
    if: github.event.issue.pull_request
    runs-on: ubuntu-latest
    steps:
      - name: find comment
        uses: peter-evans/find-comment@v1
        id: fc
        with:
          issue-number: ${{ github.event.issue.number }}
          body-includes: '# ðŸ“š ciflow test plan!'

      - name: add comment block
        uses: actions/github-script@v4
        if: steps.fc.outputs.comment-id == 0
        with:
          script: |
            const body = `
            # ðŸ“š ciflow test plan!
            - [x] ci/default
              - ciflow_lint.yml
              - ciflow_linux.yml
              - ciflow_windows.yml
              - ciflow_mac.yml
            - [ ] ci/extra
              - ciflow_linux_extra.yml
              - ciflow_windows_extra.yml
              - ciflow_mac_extra.yml
            - [ ] ci/cuda
              - ciflow_windows_cuda.yml
            ----
            `
            github.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: body
            })

      - name: dispatch labels
        uses: actions/github-script@v4
        if: steps.fc.outputs.comment-id == github.event.comment.id
        env:
          COMMENT_ID: ${{ steps.fc.outputs.comment-id }}
          COMMENT_BODY: ${{ steps.fc.outputs.comment-body }}
        with:
          script: |
            const {COMMENT_ID, COMMENT_BODY} = process.env
            const re = new RegExp(/-\s+\[([\s|x])\]\s+(.*)[\r\n]((\s\s-.*yml[\r\n])*)/g)

            let labels = new Array<string>()
            let match = re.exec(COMMENT_BODY)
            let workflows = new Set<string>()
            while (match) {
              const mark = match[1]
              const label = match[2]
              const w = match[3].split('\n').map(x => {
                const re = new RegExp(/-\s(.*yml)/g)
                const match = re.exec(x)
                if (!match) {
                    return ""
                }
                return match[1]
              }).filter(item => item != "")

              if (mark == "x") {
                labels.push(label)
                for (const wf of w) {
                    workflows.add(wf)
                }
              }
              match = re.exec(COMMENT_BODY)
            }

            await github.issues.addLabels({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              labels: labels
            })

            const pr = await github.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.issue.number
            })

            let rerun_workflows = new Array<string>()
            for (const wf of workflows) {
              const runs = await github.actions.listWorkflowRuns({
                owner: context.repo.owner,
                repo: context.repo.repo,
                branch: pr.data.head.ref,
                workflow_id: wf
              })

              if (runs.data && runs.data.workflow_runs.length > 0) {
                const lastRun = runs.data.workflow_runs[0]
                if (lastRun.conclusion == 'skipped') {
                  github.actions.reRunWorkflow({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    run_id: lastRun.id
                  })
                  rerun_workflows.push(wf)
                }
              }
            }

            const result = {
              timestamp: new Date(),
              labels,
              rerun_workflows,
              workflows: [...worklfows]
            }

            github.issues.updateComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              comment_id: COMMENT_ID,
              body: COMMENT_BODY + `\`\`\`json\n${JSON.stringify(result, null, 2)}\n\`\`\`\n----\n`
            })

            return result

